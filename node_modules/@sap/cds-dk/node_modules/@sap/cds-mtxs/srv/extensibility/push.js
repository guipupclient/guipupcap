const cds = require('@sap/cds/lib'), { fs, path, tar, read, rimraf, readdir } = cds.utils
const linter = require('./linter')

const activate = require('./activate')
const { collectFiles, getCompilerError } = require('../../lib/utils')
const { addCodeAnnotations } = require('./code-extensibility/annotations')

const TEMP_DIR = fs.realpathSync(require('os').tmpdir())
const LOG = cds.log('mtx')

const _readProject = async function (extension, req) {
  const root = await fs.promises.mkdtemp(`${TEMP_DIR}${path.sep}extension-`)
  try {
    await tar.xvz(extension).to(root)

    let extCsn = {}
    try { extCsn = JSON.parse(await read(path.join(root, 'extension.csn'))) }
    catch(e) { if (e.code !== 'ENOENT') throw e }

    let bundles    
    try { bundles = await read(path.join(root, 'i18n', 'i18n.json')) } 
    catch(e) { if (e.code !== 'ENOENT') throw e }

    let csvs = {}
    try { 
      const flist = await readdir(path.join(root, 'data')) 
      for(let file of flist) {
        const basename = path.basename(file)
        csvs[basename] = await read(path.join(root, 'data', file)) 
      }
    }
    catch(e) { if (e.code !== 'ENOENT') throw e }

    // REVISIT: adapt flags for side-car: use main
    let extCode = {}
    if (cds.env.requires.extensibility?.code) {
      const findings = await addCodeAnnotations(false, root, extCode, req.tenant)      
      if (findings?.length > 0) {
        let message = `Code validation failed with ${findings.length} finding(s):\n\n`
        message += findings.join('\n')        
        return req.reject(400, message)
      }
    }

    return { extCsn, bundles, csvs, extCode }
  } finally {
    rimraf (root)
  }
}

const base = async function (req) {
  const cdsFiles = cds.resolve('*').filter(f => f.startsWith(cds.root) && !f.includes('node_modules'))
  const csvObj = await cds.deploy.resources()
  const csvFiles = Object.keys(csvObj).filter(f => f.startsWith(cds.root) && !f.includes('node_modules'))
  const i18nFiles = await collectFiles(cds.root, ['.properties'])
  if (req.http?.res) req.http.res.set('content-type', 'application/octet-stream; charset=binary')
  return tar.cz([...cdsFiles, ...csvFiles, ...i18nFiles])
}

const pull = async function (req) {
  LOG.info(`pulling latest model for tenant '${req.tenant}'`)
  const { 'cds.xt.ModelProviderService': mps } = cds.services
  const csn = await mps.getCsn({
    tenant: req.tenant,
    toggles: Object.keys(cds.context.features || {}), // with all enabled feature extensions
    base: true, // without any custom extensions
    flavor: 'xtended'
  })

  req.http.res?.set('content-type', 'application/octet-stream; charset=binary')

  const temp = await fs.promises.mkdtemp(`${TEMP_DIR}${path.sep}extension-`)
  try {
    await fs.promises.writeFile(path.join(temp, 'index.csn'), cds.compile.to.json(csn))
    const config = linter.configCopyFrom(cds.env)
    await fs.promises.writeFile(path.join(temp, '.cdsrc.json'), JSON.stringify(config, null, 2))
    return await tar.cz(temp)
  } finally {
    rimraf (temp)
  }
}

const push = async function (req) {
  let { extension, tag } = req.data
  if (!extension) req.reject(400, 'Missing extension')
  const sources = typeof extension === 'string' ? Buffer.from(extension, 'base64') : extension
  const { extCsn, bundles, csvs, extCode } = await _readProject(sources, req)
  if (!extCsn.extensions && !extCode.extensions && !extCsn.definitions) req.reject(400, 'Missing or bad extension')
  if (!tag) tag = null
  if (!req.user.is('internal-user') && req.data.tenant && req.data.tenant !== req.tenant) 
    req.reject(403, `No permission to push extensions to tenants other than ${req.tenant}`)
  const tenant = (req.user.is('internal-user') && req.data.tenant) || req.tenant
  if (tenant) cds.context = { tenant }

  // remove current extension with tag
  if (tag) await DELETE.from('cds.xt.Extensions').where({ tag })

  // compiler validation
  LOG.info(`validating extension '${tag}' ...`)
  const { 'cds.xt.ModelProviderService': mps } = cds.services
  // REVISIT: Isn't that also done during activate?
  const csn = await mps.getCsn(tenant, Object.keys(cds.context.features || {}))
  try {
    cds.extend(csn).with(extCsn)
  } catch (err) {
    return req.reject(400, getCompilerError(err.messages))
  }

  // extension linters
  const findings = linter.lint(extCsn, csn, cds.env, extCode)
  if (findings.length > 0) {
    let message = `Validation for ${tag} failed with ${findings.length} finding(s):\n\n`
    message += findings.map(f => '  - ' + f.message).join('\n') + '\n'
    return req.reject(400, message)
  }  

  // merge csn and code
  if (!extCsn.extensions) extCsn.extensions = []
  if (extCode?.extensions?.length) extCsn.extensions.push(...extCode.extensions)

  // insert and activate extension
  const ID = cds.utils.uuid()
  await INSERT.into('cds.xt.Extensions').entries({
    ID,
    csn: JSON.stringify(extCsn),
    i18n: bundles ? JSON.stringify(bundles) : null,
    sources,
    activated: 'database',
    tag
  })

  LOG.info(`activating extension '${tag}' ...`)
  await activate(ID, null, tenant, csvs)
}

module.exports = { base, push, pull }
