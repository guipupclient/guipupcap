const { URL } = require('url')
const axios = require('axios')
const cds = require('@sap/cds/lib')
const LOG = cds.log('mtx')

module.exports = class SaasRegistryUtil {

    static async sendResult(callbackUrl, tenant, payload, authHeader) {
        const { status, message, subscriptionUrl, saasCallbackUrl, saasRequestPayload } = payload
        const data = { subscriptionUrl, message, status }

        // call to internal application callback -> piggyback original SaaS registry payload
        if (saasCallbackUrl) {
            Object.assign(data, { tenant, saasCallbackUrl, saasRequestPayload })
        }

        const headers = {}
        headers.authorization = authHeader ?? `Bearer ${await SaasRegistryUtil._getAuthToken()}`

        LOG.info('Sending result callback request to', callbackUrl)
        LOG.debug('Sending result with payload', data)

        // REVISIT: internal call - necessary?
        if (saasCallbackUrl) {
            Object.assign(headers, { status_callback: saasCallbackUrl })
        }

        try {
            return await axios(callbackUrl, { method: 'PUT', headers, data })
        } catch (error) {
            cds.error('Error sending result callback to saas-registry: ' + error.message) // REVISIT: Just throw error?
        }
    }

    static async _getAuthToken() {
        const { clientid, clientsecret, url } =
            cds.env.requires.multitenancy?.credentials ??
            cds.env.requires['cds.xt.SaasProvisioningService']?.credentials ?? {}

        if (!clientid || !clientsecret || !url) {
            cds.error('No saas-registry credentials available from the application environment.', { status: 401 })
        }

        try {
            LOG.info(`Getting saas-registry auth token from ${url}`)
            const { data: { access_token } } = await axios(`${url}/oauth/token`, {
                method: 'POST',
                auth: {
                    username: clientid,
                    password: clientsecret,
                },
                headers: {
                    'Content-Type': 'application/json'
                },
                params: {
                    grant_type: 'client_credentials',
                    response_type: 'token'
                },
            })
            if (!access_token) {
                cds.error('Could not get saas-registry token: token is empty', { status: 401 })
            }
            return access_token
        } catch (error) {
            cds.error('Could not get auth token for saas-registry: ' + error.message, { status: 401 }) // REVISIT: Just throw error?
        }
    }

    static getCallbackUrlsFromHeaders(req) {
        class CallbackHeaders {
            constructor(headers = {}) {
                const { prefer, status_callback } = headers
                if (prefer?.includes('respond-async')) {
                    this.respondAsync = true
                }
                if (status_callback) {
                    const { saas_registry_url } =
                      cds.env.requires.multitenancy?.credentials ??
                      cds.env.requires['cds.xt.SaasProvisioningService']?.credentials ?? {}
                    this.saasCallbackUrlPath = status_callback
                    this.saasCallbackUrl = new URL(status_callback, saas_registry_url).toString()
                    const { mtx_status_callback } = headers
                    this.mtxCallbackUrl = mtx_status_callback
                }
            }
            get callbackUrl() {
                return this.mtxCallbackUrl ?? this.saasCallbackUrl
            }
            get isSync() {
                return !this.saasCallbackUrl && !this.respondAsync
            }
            get isInternalCallback() {
                return !!this.mtxCallbackUrl
            }
            get noCallback() {
                return this.respondAsync && !this.callbackUrl
            }
        }
        return new CallbackHeaders(req?.headers)
    }
}
